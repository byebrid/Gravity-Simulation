import matplotlib.pyplot as plt
import numpy as np
from random import randint
import time
#things you can change
numOfObjects = 10
timeStep = 10
numOfSteps = 5000
gravConstant =  6.674 * 10**-11
lowMass = 1
upMass = 20000
lowPos = 0
upPos = 1000

#things you can't change. Not entirely sure why I had to add 1 to numOfSteps but that's what makes it work so yeah
timeArray = np.arange(0, (numOfSteps + 1) * timeStep, timeStep)
globalSteps = 0
objList = []
deadObjList = []

def lastInList(objx, propertyx):
    return objx[propertyx][len(objx[propertyx]) - 1]

def testForCollisions(tol):
    goneThroughList = False
    while goneThroughList == False:
        collisionCount = 0
        for obj1 in objList:
            for obj2 in objList:
                if obj1 == obj2 and obj2 == objList[len(objList) - 1]:
                    goneThroughList = True
                    break
                elif obj1 == obj2:
                    continue
                #if the objects are within the tolerance variable difference (which I can change as the argument)
                elif abs(lastInList(obj1, 'positions') - lastInList(obj2, 'positions')) < tol and objList.index(obj1) < len(objList) - collisionCount and objList.index(obj2) < len(objList) - collisionCount:
                    #summing the masses to get the mass of the new object
                    totalMass = obj1['mass'] + obj2['mass']
                    #summing the momentums to get the total momentum of the new object
                    netMomentum = obj1['mass'] * obj1['velocity'] + obj2['mass'] * obj2['velocity']
                    #just choosing the midpoint between the two objects as the new object's position
                    newPosition = (lastInList(obj1, 'positions') + lastInList(obj2, 'positions')) / 2
                    #using new object's momentum to find its velocity
                    newVelocity = netMomentum / totalMass
                    #making the new object in the list with its new mass, position and velocity
                    objList.append({'acceleration': 0, 
                                    'distances': [], 
                                    'mass': totalMass, 
                                    'netForce': 0, 
                                    'velocity': newVelocity, 
                                    'positions': [newPosition], 
                                    'steps': 0, 
                                    'initStep': globalSteps,
                                    'deadStep': 0
                                    })
                    #setting up deadSteps so I know where on the timeline to plot them later on
                    obj1['deadStep'] = globalSteps
                    obj2['deadStep'] = globalSteps
                    #adding the old objects to a 'dead object' list and removing them from the actual objList
                    deadObjList.append(obj1)
                    deadObjList.append(obj2)
                    objList.remove(obj1)
                    objList.remove(obj2)
                    #setting up new object's blank parameters
                    for item in range(numOfObjects - 1):
                        objList[len(objList) - 1]['distances'].append(0)
   
                    collisionCount += 1            
                    break     
 
#function that finds gravitational force between two objects
def calcGrav(obj1,obj2):
    if objList.index(obj2) > objList.index(obj1):
        if obj1['distances'][objList.index(obj2) - 1] != 0:
            d = obj1['distances'][objList.index(obj2) - 1]
            f = obj1['mass'] * obj2['mass'] * gravConstant / d**2
        else:
            f = 0
    else:
        if obj1['distances'][objList.index(obj2)] != 0:
            d = obj1['distances'][objList.index(obj2)]
            f = -1 * obj1['mass'] * obj2['mass'] * gravConstant / d**2
        else:
            f = 0
    return f

#this sets up templates for objects
for obj in range(numOfObjects):
    objList.append({'acceleration': 0, 
                    'distances': [], 
                    'mass': 0, 
                    'netForce': 0, 
                    'velocity': 0, 
                    'positions': [], 
                    'steps': 0, 
                    'initStep': 0, 
                    'deadStep': 0})
   
#this records all masses and positions of objects 
for obj in objList:
    obj['mass'] = randint(lowMass,upMass)
    obj['positions'].append(randint(lowPos,upPos))
    print 'Object number', objList.index(obj), ':', 'mass =',obj['mass'],', pos =',obj['positions']
    
    #this sets up the empty elements for distances
    for item in range(numOfObjects - 1):
        obj['distances'].append(0)

while numOfSteps > 0:
    numOfSteps -= 1
    globalSteps += 1
    numOfObjects = len(objList)
    #I believe this sorts by position but I'm not sure
    objList.sort(key=lambda objList: objList['positions'])
    
    #this finds all distance between objects (includes direction)    
    for obj1 in objList:
        obj1['steps'] += 1
        thisStep = False
        #finding lastPosition in obj1 her for greater efficiency in the nested for loop below (don't have to calculate it over and over)
        lastPos1 = lastInList(obj1, 'positions')
        for obj2 in range(numOfObjects - 1):
            lastPos2 = lastInList(objList[obj2], 'positions')
            if objList.index(obj1) == obj2:
                #thisStep keeps track of whether obj2 has a greater index than obj1 in objList. This is needed because distances array has index one less than objList
                thisStep = True
                continue
            elif thisStep == False:
                obj1['distances'][obj2] = lastPos2 - lastPos1
            else:
                obj1['distances'][obj2 - 1] = lastPos2 - lastPos1
    
    #this finds all forces acting on the objects and the consequent accelerations.       
    for obj1 in objList:
        obj1['netForce'] = 0
        for obj2 in objList:
            if obj1 == obj2:
                continue
            else:
                obj1['netForce'] += calcGrav(obj1, obj2)
        #F = ma
        #I think there might be a bottleneck here but I'm not sure 
        obj1['acceleration'] = obj1['netForce'] / obj1['mass']
        #using inital velocity and acceleration to find next position
        #s = ut + 0.5at^2
        obj1['positions'].append(obj1['velocity'] * timeStep + 0.5 * obj1['acceleration'] * timeStep**2 + lastInList(obj1, 'positions'))
        #calculating final velocity
        #v = u + at
        obj1['velocity'] += obj1['acceleration'] * timeStep
    #this is using the function defined above to see if any objects are within (argument in brackets) metres of each other
    testForCollisions(0.5)
    
#this is plotting the current objects
for obj in objList:
    initStep = obj['initStep']
    t = timeArray[initStep:]
    pos = obj['positions']
    plt.plot(t, pos)
    
#this is plotting the objects that 'died'
for deadObj in deadObjList:
    initStep = deadObj['initStep'] 
    deadStep = deadObj['deadStep'] + 1
    t = timeArray[initStep:deadStep]
    pos = deadObj['positions']
    plt.plot(t, pos)

plt.xlabel('Time (s)')
plt.ylabel('Position (m')
plt.savefig('/Users/lexgallon/desktop/tempGravSim.png', dpi = 3000)
plt.show()
